{
  "metadata": {
    "category": "pluggable-widgets",
    "lastUpdated": "2025-12-08",
    "verifiedWith": "mendix@11.5.0",
    "source": "Live verification testing - December 2025",
    "totalEntries": 6
  },
  "verified_patterns": {
    "note": "ALL patterns below have been verified through TypeScript compilation with mendix@11.5.0",
    "verification_date": "2025-12-08",
    "test_location": "MxprtWorkFolder/widget-tests/"
  },
  "entries": [
    {
      "id": "widget_types_core",
      "title": "Core Pluggable Widget Types",
      "category": "types",
      "description": "Essential types for building pluggable widgets - all verified to compile correctly",
      "verified": true,
      "content": {
        "import_statement": "import { EditableValue, DynamicValue, ActionValue, ListValue, ListAttributeValue, ListActionValue, SelectionSingleValue, ListExpressionValue, ListWidgetValue } from 'mendix';",
        "types_explained": {
          "EditableValue<T>": {
            "purpose": "Two-way binding for editable attributes",
            "properties": [
              "value: T | undefined",
              "displayValue: string",
              "status: ValueStatus",
              "validation: string | undefined",
              "readOnly: boolean"
            ],
            "methods": [
              "setValue(value: T): void",
              "setTextValue(text: string): void",
              "setValidator(validator: (value: T | undefined) => string | undefined): void"
            ],
            "usage_example": "const textValue: EditableValue<string> = props.textAttribute;\nif (textValue.status === 'available') {\n    textValue.setValue('new value');\n}"
          },
          "DynamicValue<T>": {
            "purpose": "One-way binding for computed/expression values",
            "properties": ["value: T | undefined", "status: ValueStatus"],
            "usage_example": "const label: DynamicValue<string> = props.labelExpression;\nif (label.status === 'available') {\n    return <span>{label.value}</span>;\n}"
          },
          "ActionValue": {
            "purpose": "Execute microflows, nanoflows, or other actions",
            "properties": ["canExecute: boolean", "isExecuting: boolean"],
            "methods": ["execute(): void"],
            "usage_example": "const action: ActionValue = props.onClickAction;\nif (action?.canExecute) {\n    action.execute();\n}"
          },
          "ListValue": {
            "purpose": "Access list of objects from data source",
            "properties": [
              "status: ValueStatus",
              "items: ObjectItem[] | undefined",
              "hasMoreItems: boolean",
              "totalCount: number | undefined",
              "limit: number",
              "offset: number"
            ],
            "methods": [
              "setLimit(limit: number): void",
              "setOffset(offset: number): void",
              "requestTotalCount(needed: boolean): void"
            ],
            "usage_example": "const list: ListValue = props.dataSource;\nif (list.status === 'available' && list.items) {\n    return list.items.map(item => ...);\n}"
          },
          "ListAttributeValue<T>": {
            "purpose": "Access attribute values for list items",
            "methods": ["get(item: ObjectItem): DynamicValue<T>"],
            "usage_example": "const nameAttr: ListAttributeValue<string> = props.nameAttribute;\nconst name = nameAttr.get(item);\nif (name.status === 'available') {\n    return name.value;\n}"
          },
          "ListActionValue": {
            "purpose": "Execute actions for specific list items",
            "methods": ["get(item: ObjectItem): ActionValue | undefined"],
            "usage_example": "const itemAction: ListActionValue = props.onItemClick;\nconst action = itemAction?.get(item);\nif (action?.canExecute) {\n    action.execute();\n}"
          },
          "SelectionSingleValue": {
            "purpose": "Single item selection from a list",
            "properties": ["type: 'Single'", "selection: ObjectItem | undefined"],
            "methods": ["setSelection(item: ObjectItem | undefined): void"],
            "usage_example": "const selection: SelectionSingleValue = props.selection;\nif (selection.selection) {\n    // Item is selected\n}"
          },
          "ListExpressionValue<T>": {
            "purpose": "Evaluate expression for each list item",
            "methods": ["get(item: ObjectItem): DynamicValue<T>"],
            "usage_example": "const expr: ListExpressionValue<boolean> = props.visibilityExpression;\nconst isVisible = expr.get(item);\nif (isVisible.value === true) { ... }"
          },
          "ListWidgetValue": {
            "purpose": "Render widget content for each list item",
            "methods": ["get(item: ObjectItem): ReactNode"],
            "usage_example": "const content: ListWidgetValue = props.itemContent;\nreturn list.items.map(item => (\n    <div key={item.id}>{content.get(item)}</div>\n));"
          }
        }
      }
    },
    {
      "id": "widget_hooks_verified",
      "title": "Verified Mendix React Hooks",
      "category": "hooks",
      "description": "React hooks provided by mendix package - all verified to compile correctly",
      "verified": true,
      "content": {
        "import_statement": "import { useConst, useSetup, useDebounce, useLazyListValue, useSelectionHelper, useOnResetValueEvent, useOnSetValueEvent, useFilterAPI } from 'mendix';",
        "hooks_explained": {
          "useConst<T>": {
            "purpose": "Create a constant value that persists across renders",
            "signature": "useConst<T>(factory: () => T): T",
            "usage_example": "const stableConfig = useConst(() => ({ id: generateId() }));"
          },
          "useSetup": {
            "purpose": "Run setup logic once when component mounts (like useEffect with empty deps)",
            "signature": "useSetup(setup: () => void | (() => void)): void",
            "usage_example": "useSetup(() => {\n    console.log('Widget mounted');\n    return () => console.log('Widget unmounted');\n});"
          },
          "useDebounce<T>": {
            "purpose": "Debounce a value to prevent excessive updates",
            "signature": "useDebounce<T>(value: T, delay: number): T",
            "usage_example": "const debouncedSearch = useDebounce(searchTerm, 300);"
          },
          "useLazyListValue": {
            "purpose": "Efficiently load list data with lazy loading support",
            "signature": "useLazyListValue(listValue: ListValue | undefined): ListValue | undefined",
            "usage_example": "const lazyList = useLazyListValue(props.dataSource);"
          },
          "useSelectionHelper": {
            "purpose": "Manage selection state for list widgets",
            "signature": "useSelectionHelper(selection: SelectionSingleValue | SelectionMultiValue | undefined, items: ObjectItem[] | undefined): SelectionHelper",
            "usage_example": "const helper = useSelectionHelper(props.selection, list?.items);"
          },
          "useOnResetValueEvent": {
            "purpose": "Handle reset value events from Mendix runtime",
            "signature": "useOnResetValueEvent(editableValue: EditableValue<any> | undefined, callback: () => void): void",
            "usage_example": "useOnResetValueEvent(props.textAttribute, () => setLocalValue(''));"
          },
          "useOnSetValueEvent": {
            "purpose": "Handle set value events from Mendix runtime",
            "signature": "useOnSetValueEvent<T>(editableValue: EditableValue<T> | undefined, callback: (value: T | undefined) => void): void",
            "usage_example": "useOnSetValueEvent(props.textAttribute, (newValue) => setLocalValue(newValue ?? ''));"
          },
          "useFilterAPI": {
            "purpose": "Access filter API for data grid filtering",
            "signature": "useFilterAPI(): FilterAPI",
            "usage_example": "const filterAPI = useFilterAPI();"
          }
        }
      }
    },
    {
      "id": "widget_filter_builders",
      "title": "Filter Builders API",
      "category": "filters",
      "description": "Types for building Data Grid filters - types compile but functions are runtime-only",
      "verified": true,
      "content": {
        "import_statement": "import type { FilterCondition, FilterFunctionBinary, FilterFunctionGeneric, FilterFunctionNonValue, FilterFunctionUnary } from 'mendix/filters/builders';",
        "important_note": "Filter builder FUNCTIONS (equals, contains, etc.) are NOT exported from the package. They are provided by Mendix at runtime through the filter context. The TYPES are available for TypeScript development.",
        "available_types": [
          "FilterCondition - Union of all filter condition types",
          "FilterFunctionBinary - For two-value comparisons (between)",
          "FilterFunctionGeneric - Generic filter function type",
          "FilterFunctionNonValue - For empty/notEmpty checks",
          "FilterFunctionUnary - For single-value comparisons (equals, contains, etc.)"
        ],
        "runtime_usage": "Filter functions are accessed through FilterContext provided by Data Grid widgets at runtime, not imported directly"
      }
    },
    {
      "id": "widget_xml_structure",
      "title": "Widget XML Configuration",
      "category": "configuration",
      "description": "Structure of widget.xml defining widget properties",
      "verified": true,
      "content": {
        "basic_structure": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<widget id=\"com.company.mywidget\" pluginWidget=\"true\" needsEntityContext=\"true\" xmlns=\"http://www.mendix.com/widget/1.0/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.mendix.com/widget/1.0/ ../node_modules/mendix/custom_widget.xsd\">\n    <name>My Widget</name>\n    <description>Widget description</description>\n    <studioProCategory>Display</studioProCategory>\n    <properties>\n        <!-- Properties defined here -->\n    </properties>\n</widget>",
        "property_types": {
          "attribute": "Link to entity attribute - creates EditableValue<T> or DynamicValue<T>",
          "expression": "Expression that returns a value - creates DynamicValue<T>",
          "action": "Microflow/nanoflow action - creates ActionValue",
          "datasource": "Data source configuration - creates ListValue",
          "widgets": "Container for child widgets - creates ListWidgetValue"
        },
        "example_properties": {
          "string_attribute": "<property key=\"textAttribute\" type=\"attribute\">\n    <caption>Text</caption>\n    <description>Attribute to display/edit</description>\n    <attributeTypes>\n        <attributeType name=\"String\"/>\n    </attributeTypes>\n</property>",
          "action_property": "<property key=\"onClickAction\" type=\"action\">\n    <caption>On Click</caption>\n    <description>Action when clicked</description>\n</property>",
          "datasource_property": "<property key=\"dataSource\" type=\"datasource\" isList=\"true\">\n    <caption>Data source</caption>\n    <description>Items to display</description>\n</property>"
        }
      }
    },
    {
      "id": "widget_best_practices",
      "title": "Pluggable Widget Best Practices",
      "category": "best-practices",
      "description": "Recommended patterns for building reliable widgets",
      "verified": true,
      "content": {
        "always_check_status": {
          "description": "Always check value status before using values",
          "example": "if (props.attribute?.status === 'available') {\n    // Safe to use props.attribute.value\n}"
        },
        "handle_loading": {
          "description": "Handle loading and unavailable states gracefully",
          "example": "if (props.dataSource?.status !== 'available') {\n    return <Loading />;\n}"
        },
        "use_optional_chaining": {
          "description": "Properties can be undefined - always use optional chaining",
          "example": "const canClick = props.action?.canExecute ?? false;"
        },
        "controlled_vs_uncontrolled": {
          "description": "Decide if widget manages its own state or is fully controlled by Mendix",
          "pattern": "Use local state for intermediate edits, sync to Mendix on blur/enter"
        },
        "performance_tips": [
          "Use useMemo/useCallback for expensive computations",
          "Use useLazyListValue for large lists",
          "Use useDebounce for frequent updates like search/typing"
        ]
      }
    },
    {
      "id": "widget_project_structure",
      "title": "Widget Project Structure",
      "category": "project-setup",
      "description": "Recommended folder structure for pluggable widget development",
      "verified": true,
      "content": {
        "structure": {
          "src/": {
            "MyWidget.tsx": "Main widget component",
            "MyWidget.xml": "Widget definition",
            "MyWidget.editorConfig.ts": "Studio Pro preview configuration",
            "MyWidget.editorPreview.tsx": "Preview component for Studio Pro",
            "components/": "Reusable React components",
            "hooks/": "Custom hooks",
            "utils/": "Utility functions"
          },
          "typings/": {
            "MyWidgetProps.d.ts": "Auto-generated from XML (don't edit manually)"
          },
          "package.json": "Dependencies and build scripts",
          "tsconfig.json": "TypeScript configuration"
        },
        "build_commands": {
          "dev": "pluggable-widgets-tools start:server - Development with hot reload",
          "build": "pluggable-widgets-tools build:ts - Production build",
          "lint": "pluggable-widgets-tools lint - Check code quality",
          "test": "pluggable-widgets-tools test:unit - Run unit tests"
        },
        "package_json_example": "{\n  \"name\": \"my-widget\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"pluggable-widgets-tools start:server\",\n    \"build\": \"pluggable-widgets-tools build:ts\",\n    \"lint\": \"pluggable-widgets-tools lint\"\n  },\n  \"dependencies\": {\n    \"classnames\": \"^2.3.0\"\n  },\n  \"devDependencies\": {\n    \"@mendix/pluggable-widgets-tools\": \"^10.0.0\"\n  }\n}"
      }
    }
  ]
}

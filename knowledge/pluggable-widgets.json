{
  "metadata": {
    "category": "pluggable-widgets",
    "lastUpdated": "2025-12-17",
    "verifiedWith": "mendix@11.5.0",
    "source": "Live verification testing - December 2025",
    "totalEntries": 10
  },
  "verified_patterns": {
    "note": "ALL patterns below have been verified through TypeScript compilation with mendix@11.5.0",
    "verification_date": "2025-12-08",
    "test_location": "MxprtWorkFolder/widget-tests/"
  },
  "entries": [
    {
      "id": "widget_types_core",
      "title": "Core Pluggable Widget Types",
      "category": "types",
      "description": "Essential types for building pluggable widgets - all verified to compile correctly",
      "verified": true,
      "content": {
        "import_statement": "import { EditableValue, DynamicValue, ActionValue, ListValue, ListAttributeValue, ListActionValue, SelectionSingleValue, ListExpressionValue, ListWidgetValue } from 'mendix';",
        "types_explained": {
          "EditableValue<T>": {
            "purpose": "Two-way binding for editable attributes",
            "properties": [
              "value: T | undefined",
              "displayValue: string",
              "status: ValueStatus",
              "validation: string | undefined",
              "readOnly: boolean"
            ],
            "methods": [
              "setValue(value: T): void",
              "setTextValue(text: string): void",
              "setValidator(validator: (value: T | undefined) => string | undefined): void"
            ],
            "usage_example": "const textValue: EditableValue<string> = props.textAttribute;\nif (textValue.status === 'available') {\n    textValue.setValue('new value');\n}"
          },
          "DynamicValue<T>": {
            "purpose": "One-way binding for computed/expression values",
            "properties": ["value: T | undefined", "status: ValueStatus"],
            "usage_example": "const label: DynamicValue<string> = props.labelExpression;\nif (label.status === 'available') {\n    return <span>{label.value}</span>;\n}"
          },
          "ActionValue": {
            "purpose": "Execute microflows, nanoflows, or other actions",
            "properties": ["canExecute: boolean", "isExecuting: boolean"],
            "methods": ["execute(): void"],
            "usage_example": "const action: ActionValue = props.onClickAction;\nif (action?.canExecute) {\n    action.execute();\n}"
          },
          "ListValue": {
            "purpose": "Access list of objects from data source",
            "properties": [
              "status: ValueStatus",
              "items: ObjectItem[] | undefined",
              "hasMoreItems: boolean",
              "totalCount: number | undefined",
              "limit: number",
              "offset: number"
            ],
            "methods": [
              "setLimit(limit: number): void",
              "setOffset(offset: number): void",
              "requestTotalCount(needed: boolean): void"
            ],
            "usage_example": "const list: ListValue = props.dataSource;\nif (list.status === 'available' && list.items) {\n    return list.items.map(item => ...);\n}"
          },
          "ListAttributeValue<T>": {
            "purpose": "Access attribute values for list items",
            "methods": ["get(item: ObjectItem): DynamicValue<T>"],
            "usage_example": "const nameAttr: ListAttributeValue<string> = props.nameAttribute;\nconst name = nameAttr.get(item);\nif (name.status === 'available') {\n    return name.value;\n}"
          },
          "ListActionValue": {
            "purpose": "Execute actions for specific list items",
            "methods": ["get(item: ObjectItem): ActionValue | undefined"],
            "usage_example": "const itemAction: ListActionValue = props.onItemClick;\nconst action = itemAction?.get(item);\nif (action?.canExecute) {\n    action.execute();\n}"
          },
          "SelectionSingleValue": {
            "purpose": "Single item selection from a list",
            "properties": ["type: 'Single'", "selection: ObjectItem | undefined"],
            "methods": ["setSelection(item: ObjectItem | undefined): void"],
            "usage_example": "const selection: SelectionSingleValue = props.selection;\nif (selection.selection) {\n    // Item is selected\n}"
          },
          "ListExpressionValue<T>": {
            "purpose": "Evaluate expression for each list item",
            "methods": ["get(item: ObjectItem): DynamicValue<T>"],
            "usage_example": "const expr: ListExpressionValue<boolean> = props.visibilityExpression;\nconst isVisible = expr.get(item);\nif (isVisible.value === true) { ... }"
          },
          "ListWidgetValue": {
            "purpose": "Render widget content for each list item",
            "methods": ["get(item: ObjectItem): ReactNode"],
            "usage_example": "const content: ListWidgetValue = props.itemContent;\nreturn list.items.map(item => (\n    <div key={item.id}>{content.get(item)}</div>\n));"
          }
        }
      }
    },
    {
      "id": "widget_hooks_verified",
      "title": "Verified Mendix React Hooks",
      "category": "hooks",
      "description": "React hooks provided by mendix package - all verified to compile correctly",
      "verified": true,
      "content": {
        "import_statement": "import { useConst, useSetup, useDebounce, useLazyListValue, useSelectionHelper, useOnResetValueEvent, useOnSetValueEvent, useFilterAPI } from 'mendix';",
        "hooks_explained": {
          "useConst<T>": {
            "purpose": "Create a constant value that persists across renders",
            "signature": "useConst<T>(factory: () => T): T",
            "usage_example": "const stableConfig = useConst(() => ({ id: generateId() }));"
          },
          "useSetup": {
            "purpose": "Run setup logic once when component mounts (like useEffect with empty deps)",
            "signature": "useSetup(setup: () => void | (() => void)): void",
            "usage_example": "useSetup(() => {\n    console.log('Widget mounted');\n    return () => console.log('Widget unmounted');\n});"
          },
          "useDebounce<T>": {
            "purpose": "Debounce a value to prevent excessive updates",
            "signature": "useDebounce<T>(value: T, delay: number): T",
            "usage_example": "const debouncedSearch = useDebounce(searchTerm, 300);"
          },
          "useLazyListValue": {
            "purpose": "Efficiently load list data with lazy loading support",
            "signature": "useLazyListValue(listValue: ListValue | undefined): ListValue | undefined",
            "usage_example": "const lazyList = useLazyListValue(props.dataSource);"
          },
          "useSelectionHelper": {
            "purpose": "Manage selection state for list widgets",
            "signature": "useSelectionHelper(selection: SelectionSingleValue | SelectionMultiValue | undefined, items: ObjectItem[] | undefined): SelectionHelper",
            "usage_example": "const helper = useSelectionHelper(props.selection, list?.items);"
          },
          "useOnResetValueEvent": {
            "purpose": "Handle reset value events from Mendix runtime",
            "signature": "useOnResetValueEvent(editableValue: EditableValue<any> | undefined, callback: () => void): void",
            "usage_example": "useOnResetValueEvent(props.textAttribute, () => setLocalValue(''));"
          },
          "useOnSetValueEvent": {
            "purpose": "Handle set value events from Mendix runtime",
            "signature": "useOnSetValueEvent<T>(editableValue: EditableValue<T> | undefined, callback: (value: T | undefined) => void): void",
            "usage_example": "useOnSetValueEvent(props.textAttribute, (newValue) => setLocalValue(newValue ?? ''));"
          },
          "useFilterAPI": {
            "purpose": "Access filter API for data grid filtering",
            "signature": "useFilterAPI(): FilterAPI",
            "usage_example": "const filterAPI = useFilterAPI();"
          }
        }
      }
    },
    {
      "id": "widget_filter_builders",
      "title": "Filter Builders API",
      "category": "filters",
      "description": "Types for building Data Grid filters - types compile but functions are runtime-only",
      "verified": true,
      "content": {
        "import_statement": "import type { FilterCondition, FilterFunctionBinary, FilterFunctionGeneric, FilterFunctionNonValue, FilterFunctionUnary } from 'mendix/filters/builders';",
        "important_note": "Filter builder FUNCTIONS (equals, contains, etc.) are NOT exported from the package. They are provided by Mendix at runtime through the filter context. The TYPES are available for TypeScript development.",
        "available_types": [
          "FilterCondition - Union of all filter condition types",
          "FilterFunctionBinary - For two-value comparisons (between)",
          "FilterFunctionGeneric - Generic filter function type",
          "FilterFunctionNonValue - For empty/notEmpty checks",
          "FilterFunctionUnary - For single-value comparisons (equals, contains, etc.)"
        ],
        "runtime_usage": "Filter functions are accessed through FilterContext provided by Data Grid widgets at runtime, not imported directly"
      }
    },
    {
      "id": "widget_xml_structure",
      "title": "Widget XML Configuration",
      "category": "configuration",
      "description": "Structure of widget.xml defining widget properties",
      "verified": true,
      "content": {
        "basic_structure": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<widget id=\"com.company.mywidget\" pluginWidget=\"true\" needsEntityContext=\"true\" xmlns=\"http://www.mendix.com/widget/1.0/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.mendix.com/widget/1.0/ ../node_modules/mendix/custom_widget.xsd\">\n    <name>My Widget</name>\n    <description>Widget description</description>\n    <studioProCategory>Display</studioProCategory>\n    <properties>\n        <!-- Properties defined here -->\n    </properties>\n</widget>",
        "property_types": {
          "attribute": "Link to entity attribute - creates EditableValue<T> or DynamicValue<T>",
          "expression": "Expression that returns a value - creates DynamicValue<T>",
          "action": "Microflow/nanoflow action - creates ActionValue",
          "datasource": "Data source configuration - creates ListValue",
          "widgets": "Container for child widgets - creates ListWidgetValue"
        },
        "example_properties": {
          "string_attribute": "<property key=\"textAttribute\" type=\"attribute\">\n    <caption>Text</caption>\n    <description>Attribute to display/edit</description>\n    <attributeTypes>\n        <attributeType name=\"String\"/>\n    </attributeTypes>\n</property>",
          "action_property": "<property key=\"onClickAction\" type=\"action\">\n    <caption>On Click</caption>\n    <description>Action when clicked</description>\n</property>",
          "datasource_property": "<property key=\"dataSource\" type=\"datasource\" isList=\"true\">\n    <caption>Data source</caption>\n    <description>Items to display</description>\n</property>"
        }
      }
    },
    {
      "id": "widget_best_practices",
      "title": "Pluggable Widget Best Practices",
      "category": "best-practices",
      "description": "Recommended patterns for building reliable widgets",
      "verified": true,
      "content": {
        "always_check_status": {
          "description": "Always check value status before using values",
          "example": "if (props.attribute?.status === 'available') {\n    // Safe to use props.attribute.value\n}"
        },
        "handle_loading": {
          "description": "Handle loading and unavailable states gracefully",
          "example": "if (props.dataSource?.status !== 'available') {\n    return <Loading />;\n}"
        },
        "use_optional_chaining": {
          "description": "Properties can be undefined - always use optional chaining",
          "example": "const canClick = props.action?.canExecute ?? false;"
        },
        "controlled_vs_uncontrolled": {
          "description": "Decide if widget manages its own state or is fully controlled by Mendix",
          "pattern": "Use local state for intermediate edits, sync to Mendix on blur/enter"
        },
        "performance_tips": [
          "Use useMemo/useCallback for expensive computations",
          "Use useLazyListValue for large lists",
          "Use useDebounce for frequent updates like search/typing"
        ]
      }
    },
    {
      "id": "widget_project_structure",
      "title": "Widget Project Structure",
      "category": "project-setup",
      "description": "Recommended folder structure for pluggable widget development",
      "verified": true,
      "content": {
        "structure": {
          "src/": {
            "MyWidget.tsx": "Main widget component",
            "MyWidget.xml": "Widget definition",
            "MyWidget.editorConfig.ts": "Studio Pro preview configuration",
            "MyWidget.editorPreview.tsx": "Preview component for Studio Pro",
            "components/": "Reusable React components",
            "hooks/": "Custom hooks",
            "utils/": "Utility functions"
          },
          "typings/": {
            "MyWidgetProps.d.ts": "Auto-generated from XML (don't edit manually)"
          },
          "package.json": "Dependencies and build scripts",
          "tsconfig.json": "TypeScript configuration"
        },
        "build_commands": {
          "dev": "pluggable-widgets-tools start:server - Development with hot reload",
          "build": "pluggable-widgets-tools build:ts - Production build",
          "lint": "pluggable-widgets-tools lint - Check code quality",
          "test": "pluggable-widgets-tools test:unit - Run unit tests"
        },
        "package_json_example": "{\n  \"name\": \"my-widget\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"pluggable-widgets-tools start:server\",\n    \"build\": \"pluggable-widgets-tools build:ts\",\n    \"lint\": \"pluggable-widgets-tools lint\"\n  },\n  \"dependencies\": {\n    \"classnames\": \"^2.3.0\"\n  },\n  \"devDependencies\": {\n    \"@mendix/pluggable-widgets-tools\": \"^10.0.0\"\n  }\n}"
      }
    },
    {
      "id": "widget_toolbox_category",
      "verified": true,
      "description": "How to place widgets in specific Studio Pro toolbox categories",
      "content": {
        "supported_since": "Studio Pro 10.0+",
        "placement": "After <description>, before <icon>",
        "element_name": "studioProCategory",
        "verified_in": "11.5.0",
        "notes": [
          "Default category is 'Add-ons' if not specified",
          "studioCategory is deprecated (was for Mendix Studio web)",
          "Category names are case-sensitive"
        ],
        "example": "<widget id=\"mycompany.mywidget.MyWidget\" ...>\n  <name>My Widget</name>\n  <description>What it does</description>\n  <studioProCategory>Buttons</studioProCategory>\n  <icon>...</icon>",
        "available_categories": [
          "Buttons",
          "Input elements",
          "Display",
          "Data containers",
          "Menus",
          "Add-ons"
        ]
      },
      "verification_date": "2025-12-16",
      "title": "Widget Toolbox Category (studioProCategory)",
      "category": "configuration"
    },
    {
      "id": "widget_css_patterns",
      "verified": true,
      "description": "CSS patterns to avoid common widget styling issues",
      "content": {
        "tooltip_positioning": {
          "problem": "Tooltip appears far from element",
          "solution": "Use calc() not margin for positioning",
          "example": ".tooltip--right { left: calc(100% + 8px); }"
        },
        "hover_overlay": {
          "problem": "::before overlay hides button text on hover",
          "solution": "Set z-index: 0 on ::before, z-index: 1 on text elements",
          "example": ".button::before { z-index: 0; } .button span { position: relative; z-index: 1; }"
        },
        "tooltip_wrapping": {
          "problem": "Long tooltip text gets cut off",
          "solution": "white-space: normal; max-width: 280px;"
        }
      },
      "verification_date": "2025-12-16",
      "title": "Widget CSS Best Practices",
      "category": "styling"
    },
    {
      "id": "widget_icon_best_practices",
      "verified": true,
      "description": "UPDATED: Correct method for large, visible widget icons in Studio Pro toolbox",
      "content": {
        "important_update": "Use EXTERNAL icon files, NOT base64 in XML!",
        "recommended_approach": {
          "method": "Bundle PNG files in widget package (MPK)",
          "why": "External files are easier to work with and display at proper sizes"
        },
        "icon_files": {
          "toolbox_icon": {
            "filename": "{WidgetName}.icon.png",
            "size": "64x64 pixels (ideal)",
            "purpose": "Toolbox list view icon"
          },
          "dark_mode_icon": {
            "filename": "{WidgetName}.icon.dark.png",
            "size": "64x64 pixels",
            "purpose": "Dark theme toolbox icon (optional)"
          },
          "tile_icon": {
            "filename": "{WidgetName}.tile.png",
            "size": "256x192 pixels",
            "purpose": "Toolbox tile view (optional)"
          }
        },
        "how_to_add": [
          "1. Create 64x64 PNG file",
          "2. Name it {WidgetName}.icon.png",
          "3. Place in src/ folder",
          "4. Build tool automatically copies to MPK root"
        ],
        "resize_code": "$src = [System.Drawing.Image]::FromFile('source.png')\n$bmp = New-Object System.Drawing.Bitmap(64, 64)\n$g = [System.Drawing.Graphics]::FromImage($bmp)\n$g.InterpolationMode = [System.Drawing.Drawing2D.InterpolationMode]::HighQualityBicubic\n$g.DrawImage($src, 0, 0, 64, 64)\n$bmp.Save('WidgetName.icon.png')",
        "deprecated_approach": {
          "method": "Base64 in <icon> XML element",
          "problem": "Icons appear too small, no size control"
        }
      },
      "verification_date": "2025-12-16",
      "title": "Widget Toolbox Icon Guidelines (CORRECTED)",
      "category": "configuration"
    },
    {
      "id": "widget_critical_fixes",
      "verified": true,
      "description": "Critical fixes and gotchas discovered through live widget development",
      "content": {
        "package_xml_naming": {
          "problem": "F4 shows 'Widget XML not found' error in Studio Pro",
          "cause": "package.xml inside MPK references wrong widget XML filename",
          "solution": "Ensure package.xml <file path='WidgetName.xml'/> matches actual XML file",
          "example": "If widget is InfoTooltipMx.xml, package.xml must reference InfoTooltipMx.xml NOT EditableFieldMx.xml"
        },
        "utf8_bom_issue": {
          "problem": "Build fails with XML parsing errors or weird characters",
          "cause": "PowerShell Set-Content -Encoding UTF8 adds BOM (Byte Order Mark)",
          "solution": "Use [System.IO.File]::WriteAllText with UTF8Encoding($false)",
          "code_example": "$utf8NoBom = New-Object System.Text.UTF8Encoding $false\n[System.IO.File]::WriteAllText($path, $content, $utf8NoBom)"
        },
        "integer_required_attribute": {
          "problem": "Build fails on integer property with required attribute",
          "cause": "Mendix widget schema does not allow required attribute on type='integer'",
          "wrong": "<property key='count' type='integer' required='true' defaultValue='0'>",
          "correct": "<property key='count' type='integer' defaultValue='0'>"
        },
        "small_widget_clickability": {
          "problem": "Small widgets (icons, badges) cannot be clicked in Studio Pro design mode",
          "cause": "Widget renders too small to hit with mouse click",
          "solution": "Add wrapper div with minimum 24x24px dimensions",
          "css_example": ".widget-wrapper { display: inline-flex; min-width: 24px; min-height: 24px; align-items: center; justify-content: center; }"
        },
        "mpk_verification": {
          "description": "Always verify MPK structure after build",
          "command": "tar -tf dist/1.0.0/org.widgetname.mpk",
          "expected": "Should list package.xml, WidgetName.xml, WidgetName.js, etc."
        }
      },
      "verification_date": "2025-12-17",
      "title": "Widget Development Critical Fixes",
      "category": "troubleshooting"
    }
  ]
}
